<!DOCTYPE html>
<html data-bs-theme="light" lang="en">

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, shrink-to-fit=no">
    <title>BTC Address Calculator</title>
    <link rel="stylesheet" href="assets/bootstrap/css/bootstrap.min.css">
    <link rel="stylesheet" href="assets/css/custom.css">
    <style>
        .output-box {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 0.25rem;
            padding: 1rem;
            margin-bottom: 1rem;
            word-wrap: break-word;
            font-family: monospace;
            font-size: 0.875rem;
        }
        .output-label {
            font-weight: bold;
            margin-bottom: 0.5rem;
            color: #495057;
        }
        .warning-box {
            background-color: #fff3cd;
            border: 1px solid #ffc107;
            border-radius: 0.25rem;
            padding: 1rem;
            margin-bottom: 1rem;
        }
        .copy-btn {
            margin-top: 0.5rem;
        }
    </style>
</head>

<body class="golden-bg">
    <nav class="navbar navbar-expand-md bg-body mb-5">
        <div class="container-fluid">
            <button class="navbar-toggler" data-bs-toggle="offcanvas" data-bs-target="#offcanvas-1">
                <span class="visually-hidden">Toggle navigation</span>
                <span class="navbar-toggler-icon"></span>
            </button>
            <div class="offcanvas offcanvas-start w-75" tabindex="-1" id="offcanvas-1">
                <div class="offcanvas-header">
                    <h5 class="offcanvas-title">Menu</h5>
                    <button class="btn-close" type="button" aria-label="Close" data-bs-dismiss="offcanvas"></button>
                </div>
                <div class="offcanvas-body">
                    <a class="navbar-brand" href="yourGoldVault.html">Gold Vault</a>
                    <ul class="navbar-nav">
                        <li class="nav-item"><a class="nav-link" href="yourGoldVault.html">Your Gold NFT Vault</a></li>
                        <li class="nav-item"><a class="nav-link" href="index.html">NFT Marketplace</a></li>
                        <li class="nav-item"><a class="nav-link" href="create.html">Mint Gold</a></li>
                        <li class="nav-item"><a class="nav-link" href="goldKeeperList.html">Gold Keepers</a></li>
                        <li class="nav-item"><a class="nav-link active" href="btc-calculator.html">BTC Calculator</a></li>
                    </ul>
                </div>
            </div>
        </div>
    </nav>

    <div class="container">
        <div class="row justify-content-center">
            <div class="col-md-8">
                <h1 class="text-center mb-4">Bitcoin Address Calculator</h1>
                
                <div class="warning-box">
                    <strong>⚠️ Security Warning:</strong> This tool is for educational purposes only. 
                    Never use addresses generated in web browsers for storing real Bitcoin. 
                    Always use hardware wallets or secure offline tools for actual cryptocurrency storage.
                </div>

                <div class="card mb-4">
                    <div class="card-body">
                        <h5 class="card-title">Generate Bitcoin Address</h5>
                        
                        <div class="form-check mb-3">
                            <input class="form-check-input" type="radio" name="generationMode" id="modeRandom" value="random" checked onchange="toggleInputMode()">
                            <label class="form-check-label" for="modeRandom">
                                Generate Random Private Key
                            </label>
                        </div>
                        <div class="form-check mb-3">
                            <input class="form-check-input" type="radio" name="generationMode" id="modeCustom" value="custom" onchange="toggleInputMode()">
                            <label class="form-check-label" for="modeCustom">
                                Use Custom Private Key (Hex)
                            </label>
                        </div>

                        <div id="customKeySection" style="display: none;">
                            <div class="alert alert-danger" role="alert">
                                <strong>⚠️ EXTREME CAUTION:</strong> Never enter a real private key that holds funds! 
                                This tool runs in your browser and is for educational purposes only.
                            </div>
                            <div class="mb-3">
                                <label for="customPrivateKey" class="form-label">Private Key (64 hexadecimal characters):</label>
                                <input type="text" class="form-control font-monospace" id="customPrivateKey" 
                                       placeholder="Enter 64 hex characters (0-9, a-f)" maxlength="64">
                                <div class="form-text">Example: a1b2c3d4e5f6... (32 bytes = 64 hex chars)</div>
                            </div>
                        </div>

                        <button class="btn btn-primary btn-lg w-100" id="generateBtn" onclick="generateBitcoinAddress()">
                            Generate Bitcoin Address
                        </button>
                    </div>
                </div>

                <div id="outputSection" style="display: none;">
                    <div class="card">
                        <div class="card-body">
                            <h5 class="card-title mb-3">Generated Bitcoin Address Details</h5>
                            
                            <div class="output-label">Private Key (WIF):</div>
                            <div class="output-box" id="privateKeyOutput"></div>
                            <button class="btn btn-sm btn-secondary copy-btn" onclick="copyToClipboard('privateKeyOutput', this)">
                                Copy Private Key
                            </button>

                            <div class="output-label mt-3">Public Key (Compressed):</div>
                            <div class="output-box" id="publicKeyOutput"></div>
                            <button class="btn btn-sm btn-secondary copy-btn" onclick="copyToClipboard('publicKeyOutput', this)">
                                Copy Public Key
                            </button>

                            <div class="output-label mt-3">Bitcoin Address (P2PKH):</div>
                            <div class="output-box" id="addressOutput"></div>
                            <button class="btn btn-sm btn-secondary copy-btn" onclick="copyToClipboard('addressOutput', this)">
                                Copy Address
                            </button>

                            <div class="alert alert-info mt-3" role="alert">
                                <strong>Note:</strong> Keep your private key secure and never share it with anyone. 
                                The Bitcoin address can be shared publicly to receive payments.
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="assets/bootstrap/js/bootstrap.min.js"></script>
    
    <script>
        // Simplified Bitcoin address generation using deterministic approach
        // This is for educational/demonstration purposes only
        
        function toggleInputMode() {
            const mode = document.querySelector('input[name="generationMode"]:checked').value;
            const customKeySection = document.getElementById('customKeySection');
            
            if (mode === 'custom') {
                customKeySection.style.display = 'block';
            } else {
                customKeySection.style.display = 'none';
            }
        }

        async function generateBitcoinAddress() {
            try {
                let privateKeyHex;
                const mode = document.querySelector('input[name="generationMode"]:checked').value;
                
                if (mode === 'custom') {
                    // Use custom private key
                    const customKey = document.getElementById('customPrivateKey').value.trim().toLowerCase();
                    
                    // Validate input
                    if (!customKey) {
                        alert('Please enter a private key');
                        return;
                    }
                    
                    if (customKey.length !== 64) {
                        alert('Private key must be exactly 64 hexadecimal characters (32 bytes)');
                        return;
                    }
                    
                    if (!/^[0-9a-f]{64}$/.test(customKey)) {
                        alert('Private key must contain only hexadecimal characters (0-9, a-f)');
                        return;
                    }
                    
                    privateKeyHex = customKey;
                } else {
                    // Generate random private key (32 bytes)
                    const privateKeyArray = new Uint8Array(32);
                    crypto.getRandomValues(privateKeyArray);
                    privateKeyHex = Array.from(privateKeyArray)
                        .map(b => b.toString(16).padStart(2, '0'))
                        .join('');
                }
                
                // For demonstration, we'll create a simplified representation
                // Note: Real Bitcoin address generation requires secp256k1 elliptic curve
                // which would need external libraries. This is a simplified demo.
                
                // Generate a mock public key (in real implementation, this would use secp256k1)
                const publicKeyHex = await generateMockPublicKey(privateKeyHex);
                
                // Generate Bitcoin address from public key
                const address = await publicKeyToAddress(publicKeyHex);
                
                // Convert private key to WIF (simplified)
                const privateKeyWIF = privateKeyToWIF(privateKeyHex);
                
                // Display results
                document.getElementById('privateKeyOutput').textContent = privateKeyWIF;
                document.getElementById('publicKeyOutput').textContent = publicKeyHex;
                document.getElementById('addressOutput').textContent = address;
                document.getElementById('outputSection').style.display = 'block';
                
                // Scroll to results
                document.getElementById('outputSection').scrollIntoView({ behavior: 'smooth' });
            } catch (error) {
                alert('Error generating Bitcoin address: ' + error.message);
                console.error(error);
            }
        }

        async function generateMockPublicKey(privateKeyHex) {
            // In a real implementation, this would use secp256k1 curve
            // For demo purposes, we'll create a deterministic mock public key
            const encoder = new TextEncoder();
            const data = encoder.encode(privateKeyHex);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = new Uint8Array(hashBuffer);
            
            // Compress to 33 bytes (0x02 or 0x03 prefix + 32 bytes)
            const prefix = (hashArray[31] % 2 === 0) ? '02' : '03';
            const publicKey = prefix + Array.from(hashArray)
                .map(b => b.toString(16).padStart(2, '0'))
                .join('');
            
            return publicKey.substring(0, 66); // 33 bytes = 66 hex chars
        }

        async function publicKeyToAddress(publicKeyHex) {
            // Step 1: SHA-256 hash of public key
            const publicKeyBytes = hexToBytes(publicKeyHex);
            const sha256Hash = await crypto.subtle.digest('SHA-256', publicKeyBytes);
            
            // Step 2: RIPEMD-160 hash (we'll use SHA-256 as substitute since RIPEMD-160 isn't available)
            // In real Bitcoin implementation, RIPEMD-160 would be used
            const ripemd160Hash = await crypto.subtle.digest('SHA-256', sha256Hash);
            const hash160 = new Uint8Array(ripemd160Hash).slice(0, 20); // Take first 20 bytes
            
            // Step 3: Add version byte (0x00 for mainnet)
            const versionedHash = new Uint8Array(21);
            versionedHash[0] = 0x00;
            versionedHash.set(hash160, 1);
            
            // Step 4: Double SHA-256 for checksum
            const checksum1 = await crypto.subtle.digest('SHA-256', versionedHash);
            const checksum2 = await crypto.subtle.digest('SHA-256', checksum1);
            const checksum = new Uint8Array(checksum2).slice(0, 4);
            
            // Step 5: Concatenate versioned hash and checksum
            const addressBytes = new Uint8Array(25);
            addressBytes.set(versionedHash);
            addressBytes.set(checksum, 21);
            
            // Step 6: Base58 encode
            const address = base58Encode(addressBytes);
            
            return address;
        }

        function privateKeyToWIF(privateKeyHex) {
            // Add version byte (0x80 for mainnet) and compression flag (0x01)
            const versionByte = 0x80;
            const compressionFlag = 0x01;
            
            const extended = new Uint8Array(34);
            extended[0] = versionByte;
            extended.set(hexToBytes(privateKeyHex), 1);
            extended[33] = compressionFlag;
            
            // Calculate checksum (we'll use a simplified version)
            const checksumSource = extended.slice(0, 34);
            const checksum = Array.from(checksumSource)
                .reduce((a, b) => (a + b) % 256, 0);
            
            // Create full WIF with checksum
            const fullKey = new Uint8Array(38);
            fullKey.set(extended);
            fullKey.set([checksum, checksum, checksum, checksum], 34);
            
            return base58Encode(fullKey);
        }

        function hexToBytes(hex) {
            const bytes = new Uint8Array(hex.length / 2);
            for (let i = 0; i < hex.length; i += 2) {
                bytes[i / 2] = parseInt(hex.substring(i, i + 2), 16);
            }
            return bytes;
        }

        function base58Encode(bytes) {
            const alphabet = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
            
            // Convert bytes to BigInt
            let num = 0n;
            for (let i = 0; i < bytes.length; i++) {
                num = num * 256n + BigInt(bytes[i]);
            }
            
            // Encode to base58
            let encoded = '';
            while (num > 0n) {
                const remainder = num % 58n;
                num = num / 58n;
                encoded = alphabet[Number(remainder)] + encoded;
            }
            
            // Add leading '1's for leading zero bytes
            for (let i = 0; i < bytes.length && bytes[i] === 0; i++) {
                encoded = '1' + encoded;
            }
            
            return encoded;
        }

        function copyToClipboard(elementId, btnElement) {
            const element = document.getElementById(elementId);
            const text = element.textContent;
            
            // Fallback for browsers without clipboard API
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            document.body.appendChild(textArea);
            textArea.select();
            
            try {
                document.execCommand('copy');
                document.body.removeChild(textArea);
                
                // Show feedback
                const originalText = btnElement.textContent;
                btnElement.textContent = 'Copied!';
                btnElement.classList.remove('btn-secondary');
                btnElement.classList.add('btn-success');
                
                setTimeout(() => {
                    btnElement.textContent = originalText;
                    btnElement.classList.remove('btn-success');
                    btnElement.classList.add('btn-secondary');
                }, 2000);
            } catch (err) {
                document.body.removeChild(textArea);
                alert('Failed to copy to clipboard');
                console.error(err);
            }
        }
    </script>
</body>

</html>
